Filename: home.js
Content:
let chartInstance = null;
let originalOptions = {
    firstDropdown: [],
    secondDropdown: [],
};

document.addEventListener('DOMContentLoaded', function () {
    loadSemester();
});

function toggleSelection() {
    const category = document.getElementById('categorySelector').value;
    if (!category) return;

    axios
        .get(`/${category}s`)
        .then(function (response) {
            const dropdown = document.getElementById('firstDropdown');
            dropdown.innerHTML = '<option value="">Make selection</option>';
            originalOptions.firstDropdown = response.data;

            response.data.forEach((item) => {
                const option = new Option(item.name, item.id);
                dropdown.appendChild(option);
            });
        })
        .catch(function (error) {
            console.error('Error loading data:', error);
        });
}

function updateSecondDropdown() {
    const firstDropdown = document.getElementById('firstDropdown');
    const selectedId = firstDropdown.value;
    if (!selectedId) return;

    const category = document.getElementById('categorySelector').value;
    const relatedType = category === 'professor' ? 'module' : 'professor';

    axios
        .get(`/relations/${relatedType}/${selectedId}`)
        .then(function (response) {
            const secondDropdown = document.getElementById('secondDropdown');
            secondDropdown.innerHTML = '<option value="">Make selection</option>';
            originalOptions.secondDropdown = response.data;

            response.data.forEach((item) => {
                const option = new Option(item.name, item.id);
                secondDropdown.appendChild(option);
            });
        })
        .catch(function (error) {
            console.error('Error updating second dropdown:', error);
        });
}

function filterDropdown(dropdownId, searchTerm) {
    const dropdown = document.getElementById(dropdownId);
    const originalList = originalOptions[dropdownId];
    const filteredList = originalList.filter((item) =>
        item.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    dropdown.innerHTML = '<option value="">Make selection</option>';
    filteredList.forEach((item) => {
        const option = new Option(item.name, item.id);
        dropdown.appendChild(option);
    });
}

function loadChart() {
    const category = document.getElementById('categorySelector').value;
    const firstId = document.getElementById('firstDropdown').value;
    const secondId = document.getElementById('secondDropdown').value;
    if (!category || !firstId || !secondId) return;

    const ctx = document.getElementById('ratingChart')?.getContext('2d');
    if (!ctx) {
        console.error('Canvas element with id "ratingChart" is not found in the DOM.');
        return;
    }

    axios
        .get(`/chart?category=${category}&firstId=${firstId}&secondId=${secondId}`)
        .then(function (response) {
            const { ratingData, profIdValue, moduleIdValue } = response.data;

            document.getElementById('prof_id_hidden').value = profIdValue;
            document.getElementById('module_id_hidden').value = moduleIdValue;

            if (chartInstance) {
                chartInstance.destroy();
            }

            ratingData.scatter.forEach((d) => (d.x = Number(d.x)));
            ratingData.curve.forEach((d) => (d.x = Number(d.x)));

            chartInstance = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            type: 'scatter',
                            label: 'Individual Ratings',
                            data: ratingData.scatter,
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            showLine: false,
                        },
                        {
                            type: 'line',
                            label: 'Average Ratings',
                            data: ratingData.curve,
                            backgroundColor: 'rgba(54, 162, 235, 0.5)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            fill: false,
                            tension: 0.25,
                        },
                    ],
                },
                options: {
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Semester ID',
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Rating',
                            },
                        },
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                        },
                    },
                },
            });
        })
        .catch(function (error) {
            console.error('Error loading chart data:', error);
        });
}

function loadSemester() {
    axios
        .get('/semester')
        .then(function (response) {
            const dropdown = document.getElementById('sem_id');
            const selectedValue = dropdown.value;
            dropdown.innerHTML = '<option value="">Select Semester</option>';
            response.data.forEach((semester) => {
                const option = new Option(semester.sem_name, semester.sem_id);
                dropdown.appendChild(option);
            });
            dropdown.value = selectedValue;
            document.getElementById('sem_id_hidden').value = selectedValue;
        })
        .catch(function (error) {
            console.error('Error loading semesters:', error);
        });

    const dropdown = document.getElementById('sem_id');
    dropdown.addEventListener('change', function () {
        const selectedValue = dropdown.value;
        document.getElementById('sem_id_hidden').value = selectedValue;
    });
}

// Cookie Helper Functions
function setCookie(name, value, days) {
    const date = new Date();
    date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
    const expires = "expires=" + date.toUTCString();
    document.cookie = name + "=" + value + ";" + expires + ";path=/";
}

function getCookie(name) {
    const decodedCookie = decodeURIComponent(document.cookie);
    const cookies = decodedCookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
        let cookie = cookies[i].trim();
        if (cookie.indexOf(name + "=") === 0) {
            return cookie.substring(name.length + 1);
        }
    }
    return "";
}

// Save dropdown selections to cookies
document.getElementById('categorySelector').addEventListener('change', function () {
    setCookie('categorySelector', this.value, 1); // Store for 1 day
});

document.getElementById('firstDropdown').addEventListener('change', function () {
    setCookie('firstDropdown', this.value, 1); // Store for 1 day
});

document.getElementById('secondDropdown').addEventListener('change', function () {
    setCookie('secondDropdown', this.value, 1); // Store for 1 day
});

// Restore dropdown selections on page load
document.addEventListener('DOMContentLoaded', function () {
    const category = getCookie('categorySelector');
    const first = getCookie('firstDropdown');
    const second = getCookie('secondDropdown');

    if (category) {
        const categorySelector = document.getElementById('categorySelector');
        categorySelector.value = category;

        // Populate the first dropdown
        toggleSelection().then(() => {
            const firstDropdown = document.getElementById('firstDropdown');
            if (first) {
                firstDropdown.value = first;

                // Populate the second dropdown
                updateSecondDropdown().then(() => {
                    const secondDropdown = document.getElementById('secondDropdown');
                    if (second) {
                        secondDropdown.value = second;

                        // Load the chart after setting all selections
                        loadChart();
                    }
                });
            }
        });
    }
});

// Update toggleSelection to return a Promise
function toggleSelection() {
    const category = document.getElementById('categorySelector').value;
    if (!category) return Promise.resolve();

    return axios
        .get(`/${category}s`)
        .then(function (response) {
            const dropdown = document.getElementById('firstDropdown');
            dropdown.innerHTML = '<option value="">Make selection</option>';
            originalOptions.firstDropdown = response.data;

            response.data.forEach((item) => {
                const option = new Option(item.name, item.id);
                dropdown.appendChild(option);
            });
        })
        .catch(function (error) {
            console.error('Error loading data:', error);
        });
}

// Update updateSecondDropdown to return a Promise
function updateSecondDropdown() {
    const firstDropdown = document.getElementById('firstDropdown');
    const selectedId = firstDropdown.value;
    if (!selectedId) return Promise.resolve();

    const category = document.getElementById('categorySelector').value;
    const relatedType = category === 'professor' ? 'module' : 'professor';

    return axios
        .get(`/relations/${relatedType}/${selectedId}`)
        .then(function (response) {
            const secondDropdown = document.getElementById('secondDropdown');
            secondDropdown.innerHTML = '<option value="">Make selection</option>';
            originalOptions.secondDropdown = response.data;

            response.data.forEach((item) => {
                const option = new Option(item.name, item.id);
                secondDropdown.appendChild(option);
            });
        })
        .catch(function (error) {
            console.error('Error updating second dropdown:', error);
        });
}

document.addEventListener('DOMContentLoaded', function () {
    const openPanelButton = document.getElementById('openPanel');
    const slidingPanel = document.getElementById('slidingPanel');

    openPanelButton.addEventListener('click', () => {
        slidingPanel.classList.add('open');
    });

    slidingPanel.addEventListener('submit', (event) => {
        event.preventDefault(); // Prevent default form submission for now
        // Add your form submission logic here

        // Close the sliding panel after submission
        slidingPanel.classList.remove('open');
    });
});

----------------------------------------
Filename: sliding-panel.js
Content:
document.addEventListener('DOMContentLoaded', function () {
    const openButton = document.getElementById('openPanelButton');
    const slidingPanel = document.getElementById('slidingPanel');
  
    // Open panel
    openButton.addEventListener('click', function () {
      slidingPanel.classList.add('active');
    });
  
    // Close panel when form is submitted
    slidingPanel.querySelector('form').addEventListener('submit', function () {
      slidingPanel.classList.remove('active');
    });
  
    // Optional: Close panel when clicking outside
    document.addEventListener('click', function (event) {
      if (
        !slidingPanel.contains(event.target) &&
        !openButton.contains(event.target) &&
        slidingPanel.classList.contains('active')
      ) {
        slidingPanel.classList.remove('active');
      }
    });
  });
  
----------------------------------------
Filename: app.js
Content:
import dotenv from 'dotenv';
dotenv.config();

import {
    supabase,
    addRating,
    fetchRatings,
    fetchProfessors,
    fetchModules,
    fetchDepartments,
    fetchSemesters,
    fetchProfModRelations,
    fetchModProfRelations,
    loginUser,
    registerUser,
    resetPassword,
    updateUserProfile,
    updatePassword,
    updatePreferences,
    fetchRatingHistory,
    deleteUserAccount,
    fetchUserPreferences,
    updateUserPreferences,
    fetchActivityLogs,
    logActivity
} from './db.js';

import express from 'express';
import session from 'express-session';
import bcrypt from 'bcrypt';
import path from 'path'; // Ensure path is imported

import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const app = express();

// Set Pug as the view engine
app.set('view engine', 'pug');
app.set('views', path.join(__dirname, 'views'));

// Middleware to serve static files from 'public' directory
app.use(express.static(path.join(__dirname, 'public'))); // Ensure correct path to public directory
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// Session middleware
app.use(session({
    secret: process.env.SECRET_KEY,
    resave: false,
    saveUninitialized: true,
    cookie: { secure: false }
}));

// Activity logging middleware
app.use(async (req, res, next) => {
    const user = req.session?.user;

    if (user) {
        const activityData = {
            user_id: user.id,
            username: user.username,
            timestamp: new Date().toISOString(),
            http_method: req.method,
            url: req.originalUrl,
            ip_address: req.headers['x-forwarded-for'] || req.socket.remoteAddress,
            user_agent: req.headers['user-agent'],
        };

        try {
            await logActivity(activityData);
            console.log(`[Activity Logged]: ${JSON.stringify(activityData)}`);
        } catch (err) {
            console.error('Failed to log activity:', err);
        }
    } else {
        console.log('No user session; skipping activity logging.');
    }

    next();
});

// route definitions
app.get('/profile', (req, res) => {
    const user = req.session.user;
    if (!user) {
        return res.redirect('/login');
    }
    res.render('general', { user, activeTab: 'general' });
});

app.post('/profile/update', async (req, res) => {
    if (!req.session.user) {
        return res.status(401).send('You must be logged in to update your profile.');
    }

    const { username, email, visibility } = req.body;
    try {
        const userId = req.session.user.id;
        const { error } = await supabase
            .from('users')
            .update({ username, email, visibility })
            .eq('id', userId);

        if (error) throw error;

        // Update the session with new user data
        req.session.user = { ...req.session.user, username, email, visibility };
        res.redirect('/profile');
    } catch (err) {
        console.error('Error updating profile:', err);
        res.status(500).send('Error updating profile');
    }
});

app.get('/profile/password', (req, res) => {
    res.render('password', { activeTab: 'password' });
});

app.post('/profile/password', async (req, res) => {
    const { current_password, new_password } = req.body;
    try {
        await updatePassword(req.session.user.id, current_password, new_password);
        res.redirect('/profile/password');
    } catch (error) {
        console.error('Error updating password:', error);
        res.status(500).send('Error updating password');
    }
});

app.get('/profile/preferences', async (req, res) => {
    const user = req.session.user;
    if (!user) {
        return res.redirect('/login');
    }

    const preferences = await fetchUserPreferences(user.id);
    res.render('preferences', { user, activeTab: 'preferences', preferences });
});

app.post('/profile/preferences', async (req, res) => {
    const user = req.session.user;
    if (!user) {
        return res.redirect('/login');
    }

    const { dark_mode, email_notifications } = req.body;
    const preferences = {
        dark_mode: !!dark_mode,
        email_notifications: !!email_notifications
    };

    await updateUserPreferences(user.id, preferences);
    res.redirect('/profile/preferences');
});

app.get('/profile/history', async (req, res) => {
    try {
        const ratings = await fetchRatingHistory(req.session.user.id);
        res.render('history', { ratings, activeTab: 'history' });
    } catch (error) {
        console.error('Error fetching history:', error);
        res.status(500).send('Error fetching history');
    }
});

app.get('/profile/privacy', async (req, res) => {
    console.log('Request received for /profile/privacy');
    if (!req.session.user) {
        console.log('No session user found. Redirecting to login.');
        return res.redirect('/login');
    }

    const userId = req.session.user.id;

    try {
        const { data: user, error } = await supabase
            .from('users')
            .select('visibility')
            .eq('id', userId)
            .single();

        if (error) throw error;

        console.log('Fetched user visibility:', user.visibility);
        res.render('privacy', { user: { ...req.session.user, visibility: user.visibility }, activeTab: 'privacy' });
    } catch (err) {
        console.error('Error loading privacy settings:', err);
        res.status(500).send('Error loading privacy settings');
    }
});

app.post('/profile/privacy/update', async (req, res) => {
    if (!req.session.user) {
        return res.status(401).send('You must be logged in to update your profile.');
    }

    const { visibility } = req.body;
    try {
        const userId = req.session.user.id;
        const { error } = await supabase
            .from('users')
            .update({ visibility })
            .eq('id', userId);

        if (error) throw error;

        // Update the session with new user data
        req.session.user = { ...req.session.user, visibility };
        res.redirect('/profile/privacy');
    } catch (err) {
        console.error('Error updating privacy:', err);
        res.status(500).send('Error updating privacy');
    }
});

app.post('/profile/delete', async (req, res) => {
    try {
        await deleteUserAccount(req.session.user.id);
        req.session.destroy();
        res.redirect('/');
    } catch (error) {
        console.error('Error deleting account:', error);
        res.status(500).send('Error deleting account');
    }
});

app.get('/profile/activity', async (req, res) => {
    const user = req.session.user;
    if (!user) {
        return res.redirect('/login');
    }

    const activityLogs = await fetchActivityLogs(user.id);
    res.render('activity', { user, activeTab: 'activity', activityLogs });
});

// Redirect root URL to /home
app.get('/', (req, res) => {
    res.redirect('/home');
});

app.get('/register', (req, res) => {
    res.render('register');
});

app.post('/register', async (req, res) => {
    const { username, email, password } = req.body;
    try {
        await registerUser(username, email, password);
        res.send('User registered successfully');
    } catch (error) {
        console.error('Error registering user:', error);
        res.status(500).send('Error registering user');
    }
});

app.get('/resetpassword', (req, res) => {
    res.render('resetpassword');
});

app.post('/resetpassword', async (req, res) => {
    const { email, username } = req.body;

    try {
        if (!email && !username) {
            return res.status(400).send('Please provide a username or email.');
        }

        // Attempt to reset password based on either username or email
        const identifier = email || username;
        const result = await resetPassword(identifier);

        if (!result) {
            return res.status(404).send('User not found.');
        }

        res.send(`Password reset instructions sent to ${email || username}.`);
    } catch (error) {
        console.error('Error resetting password:', error);
        res.status(500).send('Error resetting password.');
    }
});

app.get('/login', async (req, res) => {
    res.render('login', { user: req.session.user });
});

app.post('/login', async (req, res) => {
    const { username, password } = req.body;
    try {
        const user = await loginUser(username, password);
        req.session.user = user;
        res.redirect('/home');
    } catch (error) {
        console.error('Error logging in user:', error);
        res.status(500).send('Invalid credentials');
    }
});

app.get('/logout', (req, res) => {
    req.session.destroy();
    res.redirect('/home');
});

app.get('/home', async (req, res) => {
    try {
        const { profIdValue, moduleIdValue } = req.query;

        // Fetch initial dropdown options
        const firstDropdown = await fetchProfessors('*');
        const secondDropdown = profIdValue ? await fetchModules('*') : [];

        const originalOptions = {
            firstDropdown,
            secondDropdown,
        };

        // Grade and workload options
        const gradeOptions = {
            3.5: 'Failed / F',
            4.0: 'E',
            4.5: 'D',
            5.0: 'C',
            5.5: 'B',
            6.0: 'A',
        };

        const workloadOptions = {
            1: 'Walk in the Park',
            2: 'Manageable',
            3: 'Moderate Effort',
            4: 'Challenging',
            5: 'Pain and Suffering',
        };

        res.render('home', {
            user: req.session.user,
            selectedProfIdValue: profIdValue || '',
            selectedModuleIdValue: moduleIdValue || '',
            originalOptions,
            gradeOptions,
            workloadOptions,
        });
    } catch (error) {
        console.error('Error rendering home:', error);
        res.status(500).send('Internal Server Error');
    }
});

// get professors
app.get('/professors', async (req, res) => {
    try {
        const professors = await fetchProfessors('*');
        res.json(professors);
    } catch (err) {
        console.error('Failed to fetch professors:', err);
        res.status(500).send('Failed to load page');
    }
});

// get modules
app.get('/modules', async (req, res) => {
    try {
        const modules = await fetchModules('*');
        res.json(modules);
    } catch (err) {
        console.error('Failed to fetch modules:', err);
        res.status(500).send('Failed to load page');
    }
});

// get departments
app.get('/departments', async (req, res) => {
    try {
        const departments = await fetchDepartments();
        res.json(departments);
    } catch (err) {
        console.error('Failed to fetch departments:', err);
        res.status(500).send('Failed to load page');
    }
});

// get Professor Module Relations
app.get('/relations/professor/:profName', async (req, res) => {
    try {
        const relationsPM = await fetchModProfRelations(req.params.profName);
        res.json(relationsPM);
    } catch (err) {
        console.error('Failed to fetch relations:', err);
        res.status(500).send('Failed to load page');
    }
});

// get Module Professor Relations
app.get('/relations/module/:moduleName', async (req, res) => {
    try {
        const relationsMP = await fetchProfModRelations(req.params.moduleName);
        res.json(relationsMP);
    } catch (err) {
        console.error('Failed to fetch relations:', err);
        res.status(500).send('Failed to load page');
    }
});

// get data for graphs
app.get('/chart', async (req, res) => {
    const { category, firstId, secondId } = req.query;
    try {
        const { data: rawData, profIdValue, moduleIdValue } = await fetchRatings(category, firstId, secondId);
        console.log('line 143 app.js: ==========chart===========');
        console.log('line 144 app.js: rawData:', rawData);
        console.log('line 145 app.js: profIdValue:', profIdValue, 'moduleIdValue:', moduleIdValue);
        
        const averages = {};
        const scatterData = [];
        const curveData = [];

        rawData.forEach(rating => {
            scatterData.push({ x: rating.sem_id, y: rating.rating });
            if (!averages[rating.sem_id]) {
                averages[rating.sem_id] = { sum: rating.rating, count: 1 };
            } else {
                averages[rating.sem_id].sum += rating.rating;
                averages[rating.sem_id].count++;
            }
        });

        for (let sem_id in averages) {
            curveData.push({
                x: sem_id,
                y: averages[sem_id].sum / averages[sem_id].count
            });
        }

        const ratingData = { scatter: scatterData, curve: curveData };
        res.json({ ratingData, profIdValue, moduleIdValue });
        console.log('line 168 app.js: ratingData:', ratingData);
        console.log('line 169 app.js: scatterData:', scatterData);
        console.log('line 170 app.js: curveData:', curveData);
    } catch (err) {
        console.error('Failed to fetch ratings:', err);
        res.status(500).send('Failed to load page');
    }
});

// get semesters
app.get('/semester', async (req, res) => {
    try {
        const semesterData = await fetchSemesters();
        console.log('line 181 app.js: semesterData', semesterData);
        res.json(semesterData);
    } catch (error) {
        console.error('Error fetching semesters:', error);
        res.status(500).send('Error fetching semesters');
    }
});

app.post('/submit-rating', async (req, res) => {
    if (!req.session.user) {
        return res.status(401).send('Please login to submit ratings');
    }

    const { comment, rating, prof_id_hidden, sem_id_hidden, module_id_hidden, grade, workload } = req.body;

    try {
        const user_id = req.session.user.id;

        // Save rating along with grade and workload
        await addRating(comment, rating, prof_id_hidden, sem_id_hidden, module_id_hidden, user_id, grade, workload);

        // Redirect back to the home page with the selected dropdowns
        res.redirect(`/home?profIdValue=${prof_id_hidden}&moduleIdValue=${module_id_hidden}`);
    } catch (err) {
        console.error('Error submitting rating:', err);
        res.status(500).send('Error submitting rating');
    }
});

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

----------------------------------------
Filename: db.js
Content:
import dotenv from 'dotenv';
dotenv.config();

import bcrypt from 'bcrypt';
import {
    createClient
} from '@supabase/supabase-js';

const supabaseUrl = 'https://jqnesxzpfsfxzqnudtig.supabase.co';
const supabaseKey = process.env.SUPABASE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

async function fetchProfessors(columns = '*') {
    try {
        const { data, error } = await supabase
            .from('professors')
            .select(columns);

        if (error) {
            console.error('Error fetching professors:', error);
            return []; // Return an empty array on error
        }

        if (!data || data.length === 0) {
            console.warn('No professors found.');
            return []; // Return an empty array if no data
        }

        console.log(`line 23 db.js: Fetched ${data.length} professors.`);
        return data;
    } catch (error) {
        console.error('Unexpected error fetching professors:', error);
        return []; // Return an empty array on unexpected error
    }
}

async function fetchModules(columns = '*') {
    try {
        const { data, error } = await supabase
            .from('modules')
            .select(columns);

        if (error) {
            console.error('Error fetching modules:', error);
            return []; // Return an empty array on error
        }

        if (!data || data.length === 0) {
            console.warn('No modules found.');
            return []; // Return an empty array if no data
        }

        console.log(`line 41 db.js: Fetched ${data.length} modules.`);
        return data;
    } catch (error) {
        console.error('Unexpected error fetching modules:', error);
        return []; // Return an empty array on unexpected error
    }
}

async function fetchDepartments() {
    try {
        const { data, error } = await supabase
            .from('departments')
            .select('*');

        if (error) {
            console.error('Error fetching departments:', error);
            return [];
        }
        console.log('line 59 db.js: Fetched departments:', data[0], '...');
        return data;
    } catch (error) {
        console.error('Unexpected error fetching departments:', error);
        return [];
    }
}

async function fetchSemesters() {
    try {
        const { data, error } = await supabase
        .from('semester')
        .select('*');

        if (error) {
            console.error('Error fetching semesters:', error);
            return [];
        }
        console.log('line 77 db.js: Fetched semesters:', data[0], '...');
        return data;
    } catch (error) {
        console.error('Unexpected error fetching semesters:', error);
        return [];
    }
}

async function fetchProfModRelations(profName) {
    try {
        const { data: professorData, error: professorError } = await supabase
            .from('professors')
            .select('prof_id')
            .eq('name', profName);

        if (professorError) {
            console.error('Error fetching professor data:', professorError);
            return [];
        }

        const professorIds = professorData.map(professor => professor.prof_id);

        const { data: relationsData, error: relationsError } = await supabase
            .from('professors_modules')
            .select('module_id')
            .in('prof_id', professorIds);

        if (relationsError) {
            console.error('Error fetching relations data:', relationsError);
            return [];
        }

        const moduleIds = relationsData.map(relation => relation.module_id);

        const { data: modulesData, error: modulesError } = await supabase
            .from('modules')
            .select('name, module_id')
            .in('module_id', moduleIds);

        if (modulesError) {
            console.error('Error fetching module data:', modulesError);
            return [];
        }

        return modulesData;
    } catch (error) {
        console.error('Unexpected error fetching relations:', error);
        return [];
    }
}

async function fetchModProfRelations(moduleName) {
    try {
        const { data: moduleData, error: moduleError } = await supabase
            .from('modules')
            .select('module_id')
            .eq('name', moduleName);

        if (moduleError) {
            console.error('Error fetching module data:', moduleError);
            return [];
        }

        const moduleIds = moduleData.map(module => module.module_id);

        const { data: relationsData, error: relationsError } = await supabase
            .from('professors_modules')
            .select('prof_id')
            .in('module_id', moduleIds);

        if (relationsError) {
            console.error('Error fetching relations data:', relationsError);
            return [];
        }

        const professorIds = relationsData.map(relation => relation.prof_id);

        const { data: professorsData, error: professorsError } = await supabase
            .from('professors')
            .select('name, prof_id')
            .in('prof_id', professorIds);

        if (professorsError) {
            console.error('Error fetching professor data:', professorsError);
            return [];
        }

        return professorsData;
    } catch (error) {
        console.error('Unexpected error fetching relations:', error);
        return [];
    }
}

async function fetchRatings(category, firstId, secondId) {

    console.log('line 173 db.js: 1. category passed:', category, 'profId passed:', firstId, 'moduleId passed:', secondId);
    
    let profId, moduleId;
    if (category === 'professor') {
        profId = firstId;
        moduleId = secondId;
    } else {
        profId = secondId;
        moduleId = firstId;
    }

    console.log('line 184 db.js: 2. category passed:', category, 'profId passed:', profId, 'moduleId passed:', moduleId);

    // Fetch the actual IDs from the professors and modules tables
    let profIdValue, moduleIdValue;
    
    if (profId) {
        const profData = await fetchProfessors();
        const prof = profData.find(p => p.name === profId);
        profIdValue = prof ? prof.prof_id : null;
    }

    if (moduleId) {
        const modData = await fetchModules();
        const module = modData.find(m => m.name === moduleId);
        moduleIdValue = module ? module.module_id : null;
    }

    if (!profIdValue || !moduleIdValue) {
        console.error('Invalid professor or module name provided');
        return [];
    }

    console.log('line 206 db.js: 3. Using profIdValue:', profIdValue, 'and moduleIdValue:', moduleIdValue);
    try {
        const { data, error } = await supabase
            .from('ratings')
            .select('*')
            .eq('prof_id', profIdValue)
            .eq('module_id', moduleIdValue);

        if (error) {
            console.error('Error fetching ratings:', error);
            return [];
        }
        console.log('line 218 db.js: Fetched ratings:', data[0], '...');
        return { data, profIdValue, moduleIdValue };  // Return as an object
    } catch (error) {
        console.error('Unexpected error fetching ratings:', error);
        return [];
    }
}

async function addRating(comment, rating, prof_id, sem_id, module_id, user_id, grade = null, workload = null) {
    try {
        const { data, error } = await supabase.from('ratings').insert([{
            comment,
            rating,
            prof_id,
            sem_id,
            module_id,
            user_id,
            grade,
            workload,
        }]);

        if (error) {
            console.error('Error inserting rating:', error);
            throw error;
        }

        console.log('Rating successfully added:', data);
        return data;
    } catch (error) {
        console.error('Unexpected error adding rating:', error);
        throw error;
    }
}

async function loginUser(username, password) {
    const { data: user, error } = await supabase.from('users').select('*').eq('username', username).single();
    if (error || !user) {
      throw new Error('Invalid credentials');
    }
    const match = await bcrypt.compare(password, user.password_hash);
    if (!match) {
      throw new Error('Invalid credentials');
    }
    return user;
}

async function registerUser(username, email, password) {
    const passwordHash = await bcrypt.hash(password, 10);
    const { data, error } = await supabase.from('users').insert([{ username, email, password, password_hash: passwordHash }]);
    if (error) {
        console.error('Error registering user:', error);
        throw error;
    }
    return data;
}

async function resetPassword(identifier) {
    try {
        const { data: user, error } = await supabase
            .from('users')
            .select('id, email')
            .or(`username.eq.${identifier},email.eq.${identifier}`)
            .single();

        if (error || !user) {
            console.error('User not found for reset:', error);
            return null;
        }

        const tempPassword = Math.random().toString(36).substring(2, 8); // e.g., "temp123"
        const hashedPassword = await bcrypt.hash(tempPassword, 10);

        const { error: updateError } = await supabase
            .from('users')
            .update({ password_hash: hashedPassword })
            .eq('id', user.id);

        if (updateError) {
            console.error('Error updating password:', updateError);
            return null;
        }

        await sendPasswordResetEmail(user.email, tempPassword);

        console.log(`Temporary password sent to ${user.email}`);
        return { email: user.email, tempPassword };
    } catch (error) {
        console.error('Error during password reset logic:', error);
        throw error;
    }
}

async function sendPasswordResetEmail(email, resetLink) {
    // Replace this with actual email service logic
    console.log(`Sending password reset email to ${email} with link: ${resetLink}`);
}

async function updateUserProfile(userId, username, email, visibility) {
    const { error } = await supabase
        .from('users')
        .update({ username, email, visibility })
        .eq('id', userId);
    if (error) throw error;
}

async function updatePassword(userId, currentPassword, newPassword) {
    const { data: user, error } = await supabase
        .from('users')
        .select('password_hash')
        .eq('id', userId)
        .single();

    if (error || !user) throw new Error('User not found');
    const match = await bcrypt.compare(currentPassword, user.password_hash);
    if (!match) throw new Error('Invalid current password');

    const hashedPassword = await bcrypt.hash(newPassword, 10);
    const { error: updateError } = await supabase
        .from('users')
        .update({ password_hash: hashedPassword })
        .eq('id', userId);

    if (updateError) throw updateError;
}

async function updatePreferences(userId, preferences) {
    const { error } = await supabase
        .from('users')
        .update({ preferences })
        .eq('id', userId);
    if (error) throw error;
}

async function fetchRatingHistory(userId) {
    try {
        const { data, error } = await supabase
            .from('ratings')
            .select('id, comment, rating, prof_id, sem_id, module_id, created_at')
            .eq('user_id', userId);

        if (error) {
            console.error('Error fetching rating history:', error);
            throw error;
        }

        return data;
    } catch (error) {
        console.error('Unexpected error fetching rating history:', error);
        throw error;
    }
}

async function deleteUserAccount(userId) {
    const { error } = await supabase
        .from('users')
        .delete()
        .eq('id', userId);
    if (error) throw error;
}

async function fetchUserPreferences(userId) {
    try {
        const { data, error } = await supabase
            .from('users')
            .select('preferences')
            .eq('id', userId)
            .single();

        if (error) {
            console.error('Error fetching user preferences:', error);
            throw error;
        }
        return data.preferences || {};
    } catch (error) {
        console.error('Unexpected error fetching user preferences:', error);
        return {};
    }
}

async function updateUserPreferences(userId, preferences) {
    try {
        const { error } = await supabase
            .from('users')
            .update({ preferences })
            .eq('id', userId);

        if (error) {
            console.error('Error updating user preferences:', error);
            throw error;
        }
    } catch (error) {
        console.error('Unexpected error updating user preferences:', error);
    }
}

async function fetchActivityLogs(userId) {
    try {
        const { data, error } = await supabase
            .from('activity_logs')
            .select('*')
            .eq('user_id', userId)
            .eq('visibility');

        if (error) {
            console.error('Error fetching privacy:', error);
            return [];
        }
        return data;
    } catch (error) {
        console.error('Unexpected error fetching privacy:', error);
        return [];
    }
}

export async function logActivity(activityData) {
    const { user_id, action } = activityData;

    try {
        const { data, error } = await supabase
            .from('activity')
            .insert([
                {
                    user_id,
                    action, // Simplify to include only the relevant columns
                    created_at: new Date().toISOString() // Optional: Supabase can auto-generate this
                }
            ]);

        if (error) {
            console.error('Error logging activity to database:', error);
            throw error;
        }

        return data;
    } catch (err) {
        console.error('Unexpected error during activity logging:', err);
        throw err;
    }
}

async function fetchPrivacy(userId) {
    try {
        const { data, error } = await supabase
            .from('users')
            .select('*')
            .eq('user_id', userId)
            .order('timestamp', { ascending: false });

        if (error) {
            console.error('Error fetching activity logs:', error);
            return [];
        }
        return data;
    } catch (error) {
        console.error('Unexpected error fetching activity logs:', error);
        return [];
    }
}

export {
    supabase,
    addRating,
    fetchRatings,
    fetchProfessors,
    fetchModules,
    fetchDepartments,
    fetchSemesters,
    fetchProfModRelations,
    fetchModProfRelations,
    loginUser,
    registerUser,
    resetPassword,
    updateUserProfile,
    updatePassword,
    updatePreferences,
    fetchRatingHistory,
    deleteUserAccount,
    fetchUserPreferences,
    updateUserPreferences,
    fetchActivityLogs,
    fetchPrivacy
};

----------------------------------------
Filename: hashPasswords.js
Content:
import dotenv from 'dotenv';
dotenv.config();

import { createClient } from '@supabase/supabase-js';
import bcrypt from 'bcrypt';

const supabaseUrl = 'https://jqnesxzpfsfxzqnudtig.supabase.co';
const supabaseKey = process.env.SUPABASE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

async function hashPasswords() {
  try {
    const { data: users, error } = await supabase.from('users').select('*');
    if (error) {
      console.error('Error fetching users:', error);
      return;
    }

    console.log('Fetched users:', users);

    for (const user of users) {
      // Check if the password_hash is empty or already hashed
      if (!user.password_hash || !user.password_hash.startsWith('$2b$')) {
        const passwordToHash = user.password || user.password_hash;
        const hashedPassword = await bcrypt.hash(passwordToHash, 10);
        
        const { error: updateError } = await supabase
          .from('users')
          .update({ password_hash: hashedPassword })
          .eq('id', user.id);
          
        if (updateError) {
          console.error(`Error updating user ${user.id}:`, updateError);
        } else {
          console.log(`User ${user.id} password updated.`);
        }
      } else {
        console.log(`User ${user.id} password is already hashed.`);
      }
    }
  } catch (error) {
    console.error('Unexpected error:', error);
  }
}

hashPasswords();

----------------------------------------

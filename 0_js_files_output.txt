Filename: home.js
Content:
let chartInstance = null;
let originalOptions = {
    firstDropdown: [],
    secondDropdown: [],
};

document.addEventListener('DOMContentLoaded', function () {
    loadSemester();
});
document.addEventListener('DOMContentLoaded', function () {
    const toggler = document.querySelector('.menu__toggler');
    const loginModal = document.getElementById('loginModal');
    const closeModalButton = loginModal.querySelector('.close');
    const isLoggedIn = typeof user !== 'undefined' && user; // Replace with actual user check logic

    if (toggler && !isLoggedIn) {
        toggler.addEventListener('click', (event) => {
            event.preventDefault(); // Prevent opening the sliding panel
            if (loginModal) {
                loginModal.style.display = 'block';
            }
        });
    }

    // Close modal when clicking the "X" button
    if (closeModalButton) {
        closeModalButton.addEventListener('click', () => {
            loginModal.style.display = 'none';
        });
    }

    // Close modal when clicking outside of it
    window.addEventListener('click', (event) => {
        if (loginModal && event.target === loginModal) {
            loginModal.style.display = 'none';
        }
    });
});
document.addEventListener('DOMContentLoaded', function () {
    const loadCommentsButton = document.getElementById('loadCommentsButton');
    const commentsContainer = document.getElementById('commentsContainer');

    if (loadCommentsButton && commentsContainer) {
        loadCommentsButton.addEventListener('click', function () {
            const profId = document.getElementById('prof_id_hidden').value;
            const moduleId = document.getElementById('module_id_hidden').value;

            if (!profId || !moduleId) {
                commentsContainer.innerHTML = '<p>Please select both a professor and a module to load comments.</p>';
                return;
            }

            axios
                .get(`/comments?prof_id_hidden=${profId}&module_id_hidden=${moduleId}`)
                .then((response) => {
                    const comments = response.data;
                    console.log('comment data: ', comments);

                    if (comments.length === 0) {
                        commentsContainer.innerHTML = '<p>No comments available for this selection.</p>';
                        return;
                    }

                    commentsContainer.innerHTML = ''; // Clear existing comments

                    comments.forEach((comment) => {
                        // Translations for grade, workload, and semester
                        const gradeTranslation =
                            window.gradeTranslations[comment.grade] || 'N/A';
                        const workloadTranslation =
                            window.workloadTranslations[comment.workload] || 'N/A';
                        const semesterTranslation =
                            window.translateSemester(comment.sem_id);

                        // Create comment tile
                        const commentTile = document.createElement('div');
                        commentTile.style.display = 'flex';
                        commentTile.style.flexDirection = 'column';
                        commentTile.style.justifyContent = 'space-between';
                        commentTile.style.padding = '15px';
                        commentTile.style.border = '1px solid #ccc';
                        commentTile.style.borderRadius = '8px';
                        commentTile.style.marginBottom = '15px';
                        commentTile.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
                        commentTile.style.backgroundColor = '#f9f9f9';
                        commentTile.style.position = 'relative';

                        // Header section
                        const header = document.createElement('div');
                        header.style.display = 'flex';
                        header.style.justifyContent = 'space-between';
                        header.style.width = '100%';

                        const rating = document.createElement('div');
                        rating.textContent = `Rating: ${comment.rating || 'N/A'}`;
                        rating.style.fontSize = '1.5rem';
                        rating.style.fontWeight = 'bold';
                        rating.style.color = '#007BFF';

                        const date = document.createElement('div');
                        date.textContent = new Date(comment.created_at).toLocaleDateString();
                        date.style.fontSize = '0.9rem';
                        date.style.color = '#555';
                        date.style.position = 'absolute';
                        date.style.top = '15px';
                        date.style.right = '15px';

                        header.appendChild(rating);
                        header.appendChild(date);

                        // Comment section
                        const commentText = document.createElement('div');
                        commentText.textContent = comment.comment || '';
                        commentText.style.fontSize = '1rem';
                        commentText.style.margin = '10px 0';
                        commentText.style.color = '#333';

                        // Details section
                        const details = document.createElement('div');
                        details.style.fontSize = '0.9rem';
                        details.style.color = '#666';

                        const semester = document.createElement('span');
                        semester.textContent = `Semester: ${semesterTranslation}`;

                        const grade = document.createElement('span');
                        grade.textContent = `Grade: ${gradeTranslation}`;

                        const workload = document.createElement('span');
                        workload.textContent = `Workload: ${workloadTranslation}`;

                        details.appendChild(semester);
                        details.appendChild(document.createElement('br')); // Line break for spacing
                        details.appendChild(grade);
                        details.appendChild(document.createElement('br'));
                        details.appendChild(workload);

                        // Append everything to the comment tile
                        commentTile.appendChild(header);
                        commentTile.appendChild(commentText);
                        commentTile.appendChild(details);

                        // Append the tile to the container
                        commentsContainer.appendChild(commentTile);
                    });
                })
                .catch((error) => {
                    console.error('Error loading comments:', error);
                    commentsContainer.innerHTML =
                        '<p>Failed to load comments. Please try again later.</p>';
                });
        });
    }
});

function toggleSelection() {
    const category = document.getElementById('categorySelector').value;
    if (!category) return;

    axios
        .get(`/${category}s`)
        .then(function (response) {
            const dropdown = document.getElementById('firstDropdown');
            dropdown.innerHTML = '<option value="">Make selection</option>';
            originalOptions.firstDropdown = response.data;

            response.data.forEach((item) => {
                const option = new Option(item.name, item.id);
                dropdown.appendChild(option);
            });
        })
        .catch(function (error) {
            console.error('Error loading data:', error);
        });
}

function updateSecondDropdown() {
    const firstDropdown = document.getElementById('firstDropdown');
    const selectedId = firstDropdown.value;
    if (!selectedId) return;

    const category = document.getElementById('categorySelector').value;
    const relatedType = category === 'professor' ? 'module' : 'professor';

    axios
        .get(`/relations/${relatedType}/${selectedId}`)
        .then(function (response) {
            const secondDropdown = document.getElementById('secondDropdown');
            secondDropdown.innerHTML = '<option value="">Make selection</option>';
            originalOptions.secondDropdown = response.data;

            response.data.forEach((item) => {
                const option = new Option(item.name, item.id);
                secondDropdown.appendChild(option);
            });
        })
        .catch(function (error) {
            console.error('Error updating second dropdown:', error);
        });
}

function filterDropdown(dropdownId, searchTerm) {
    const dropdown = document.getElementById(dropdownId);
    const originalList = originalOptions[dropdownId];
    const filteredList = originalList.filter((item) =>
        item.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    dropdown.innerHTML = '<option value="">Make selection</option>';
    filteredList.forEach((item) => {
        const option = new Option(item.name, item.id);
        dropdown.appendChild(option);
    });
}

function loadChart() {
    const category = document.getElementById('categorySelector').value;
    const firstId = document.getElementById('firstDropdown').value;
    const secondId = document.getElementById('secondDropdown').value;
    if (!category || !firstId || !secondId) return;

    const ctx = document.getElementById('ratingChart')?.getContext('2d');
    if (!ctx) {
        console.error('Canvas element with id "ratingChart" is not found in the DOM.');
        return;
    }

    axios
        .get(`/chart?category=${category}&firstId=${firstId}&secondId=${secondId}`)
        .then(function (response) {
            const { ratingData, profIdValue, moduleIdValue } = response.data;

            document.getElementById('prof_id_hidden').value = profIdValue;
            document.getElementById('module_id_hidden').value = moduleIdValue;

            if (chartInstance) {
                chartInstance.destroy();
            }

            ratingData.scatter.forEach((d) => (d.x = Number(d.x)));
            ratingData.curve.forEach((d) => (d.x = Number(d.x)));

            chartInstance = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            type: 'scatter',
                            label: 'Individual Ratings',
                            data: ratingData.scatter,
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            showLine: false,
                        },
                        {
                            type: 'line',
                            label: 'Average Ratings',
                            data: ratingData.curve,
                            backgroundColor: 'rgba(54, 162, 235, 0.5)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            fill: false,
                            tension: 0.25,
                        },
                    ],
                },
                options: {
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Semester ID',
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Rating',
                            },
                        },
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                        },
                    },
                },
            });
        })
        .catch(function (error) {
            console.error('Error loading chart data:', error);
        });
}

function loadSemester() {
    axios
        .get('/semester')
        .then(function (response) {
            const dropdown = document.getElementById('sem_id');
            const selectedValue = dropdown.value;
            dropdown.innerHTML = '<option value="">Select Semester</option>';
            response.data.forEach((semester) => {
                const option = new Option(semester.sem_name, semester.sem_id);
                dropdown.appendChild(option);
            });
            dropdown.value = selectedValue;
            document.getElementById('sem_id_hidden').value = selectedValue;
        })
        .catch(function (error) {
            console.error('Error loading semesters:', error);
        });

    const dropdown = document.getElementById('sem_id');
    dropdown.addEventListener('change', function () {
        const selectedValue = dropdown.value;
        document.getElementById('sem_id_hidden').value = selectedValue;
    });
}

// Cookie Helper Functions
function setCookie(name, value, days) {
    const date = new Date();
    date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
    const expires = "expires=" + date.toUTCString();
    document.cookie = name + "=" + value + ";" + expires + ";path=/";
}

function getCookie(name) {
    const decodedCookie = decodeURIComponent(document.cookie);
    const cookies = decodedCookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
        let cookie = cookies[i].trim();
        if (cookie.indexOf(name + "=") === 0) {
            return cookie.substring(name.length + 1);
        }
    }
    return "";
}

// Save dropdown selections to cookies
document.getElementById('categorySelector').addEventListener('change', function () {
    setCookie('categorySelector', this.value, 1); // Store for 1 day
});

document.getElementById('firstDropdown').addEventListener('change', function () {
    setCookie('firstDropdown', this.value, 1); // Store for 1 day
});

document.getElementById('secondDropdown').addEventListener('change', function () {
    setCookie('secondDropdown', this.value, 1); // Store for 1 day
});

// Restore dropdown selections on page load
document.addEventListener('DOMContentLoaded', function () {
    const category = getCookie('categorySelector');
    const first = getCookie('firstDropdown');
    const second = getCookie('secondDropdown');

    if (category) {
        const categorySelector = document.getElementById('categorySelector');
        categorySelector.value = category;

        // Populate the first dropdown
        toggleSelection().then(() => {
            const firstDropdown = document.getElementById('firstDropdown');
            if (first) {
                firstDropdown.value = first;

                // Populate the second dropdown
                updateSecondDropdown().then(() => {
                    const secondDropdown = document.getElementById('secondDropdown');
                    if (second) {
                        secondDropdown.value = second;

                        // Load the chart after setting all selections
                        loadChart();
                    }
                });
            }
        });
    }
});

// Update toggleSelection to return a Promise
function toggleSelection() {
    const category = document.getElementById('categorySelector').value;
    if (!category) return Promise.resolve();

    return axios
        .get(`/${category}s`)
        .then(function (response) {
            const dropdown = document.getElementById('firstDropdown');
            dropdown.innerHTML = '<option value="">Make selection</option>';
            originalOptions.firstDropdown = response.data;

            response.data.forEach((item) => {
                const option = new Option(item.name, item.id);
                dropdown.appendChild(option);
            });
        })
        .catch(function (error) {
            console.error('Error loading data:', error);
        });
}

// Update updateSecondDropdown to return a Promise
function updateSecondDropdown() {
    const firstDropdown = document.getElementById('firstDropdown');
    const selectedId = firstDropdown.value;
    if (!selectedId) return Promise.resolve();

    const category = document.getElementById('categorySelector').value;
    const relatedType = category === 'professor' ? 'module' : 'professor';

    return axios
        .get(`/relations/${relatedType}/${selectedId}`)
        .then(function (response) {
            const secondDropdown = document.getElementById('secondDropdown');
            secondDropdown.innerHTML = '<option value="">Make selection</option>';
            originalOptions.secondDropdown = response.data;

            response.data.forEach((item) => {
                const option = new Option(item.name, item.id);
                secondDropdown.appendChild(option);
            });
        })
        .catch(function (error) {
            console.error('Error updating second dropdown:', error);
        });
}
----------------------------------------
Filename: profile.js
Content:
document.addEventListener('DOMContentLoaded', () => {
    const historyCommentsContainer = document.getElementById('historyCommentsContainer');
    if (historyCommentsContainer) {
        loadUserHistory(); // Automatically load user history on page load
    }
});

function loadUserHistory() {
    const historyCommentsContainer = document.getElementById('historyCommentsContainer');

    if (!historyCommentsContainer) return;

    axios
        .get('/profile/history/data')
        .then((response) => {
            const comments = response.data;
            console.log('comment data: ', comments);

            if (comments.length === 0) {
                historyCommentsContainer.innerHTML =
                    '<p>No history available for this user.</p>';
                return;
            }

            historyCommentsContainer.innerHTML = ''; // Clear existing history
            comments.forEach((comment) => {
                // Translations for grade, workload, and semester
                const gradeTranslation =
                    window.gradeTranslations[comment.grade] || 'N/A';
                const workloadTranslation =
                    window.workloadTranslations[comment.workload] || 'N/A';
                const semesterTranslation =
                    window.translateSemester(comment.sem_id);

                const commentTile = document.createElement('div');
                commentTile.classList.add('comment-tile');
                commentTile.innerHTML = `
                    <div class="rating-header">
                        <span class="rating">Rating: ${comment.rating}</span>
                        <span class="semester">Semester: ${semesterTranslation}</span>
                    </div>
                    <div class="date-header">
                        <span class="date">${new Date(comment.created_at).toLocaleDateString()}</span>
                    </div>
                    <p class="comment">${comment.comment}</p>
                    <div class="grade-footer">
                        <span class="grade">Grade: ${gradeTranslation}</span>
                    </div>
                    <div class="workload-footer">
                        <span class="workload">Workload: ${workloadTranslation}</span>
                    </div>
                    <button class="edit-button" data-rating-id="${comment.rating_id}">Edit</button>
                `;
                historyCommentsContainer.appendChild(commentTile);
            });

            // Add event listeners to edit buttons
            addEditListeners();
        })
        .catch((error) => {
            console.error('Error loading user history:', error);
            historyCommentsContainer.innerHTML =
                '<p>Failed to load history. Please try again later.</p>';
        });
}

function addEditListeners() {
    const editButtons = document.querySelectorAll('.edit-button');
    editButtons.forEach((button) => {
        button.addEventListener('click', function () {
            const ratingId = this.getAttribute('data-rating-id');
            openEditModal(ratingId);
        });
    });
}

function openEditModal(ratingId) {
    axios
        .get(`/profile/history/${ratingId}`)
        .then((response) => {
            const rating = response.data;

            document.getElementById('editRatingId').value = rating.rating_id;
            document.getElementById('editComment').value = rating.comment;
            document.getElementById('editRating').value = rating.rating || '';
            document.getElementById('editGrade').value = rating.grade || '';
            document.getElementById('editWorkload').value = rating.workload || '';

            const editModal = document.getElementById('editModal');
            editModal.style.display = 'block';
        })
        .catch((error) => {
            console.error('Error fetching rating data:', error);
        });
}

// Close modal functionality
document.addEventListener('DOMContentLoaded', function () {
    const editModal = document.getElementById('editModal');
    const closeModalButton = editModal?.querySelector('.close');

    if (editModal && closeModalButton) {
        // Add click event listener for the close button
        closeModalButton.addEventListener('click', () => {
            editModal.style.display = 'none';
        });

        // Close the modal when clicking outside of it
        window.addEventListener('click', (event) => {
            if (event.target === editModal) {
                editModal.style.display = 'none';
            }
        });
    }
});

----------------------------------------
Filename: sliding-panel.js
Content:
document.addEventListener('DOMContentLoaded', function () {
    const toggler = document.querySelector('.menu__toggler');
    const slidingPanel = document.getElementById('slidingPanel');
    const sidebar = document.querySelector('.sidebar');
    const textarea = document.querySelector('#slidingPanel form textarea');

    if (textarea) {
        textarea.addEventListener('input', function () {
            this.style.height = 'auto'; // Reset the height to calculate the correct new height
            this.style.height = `${this.scrollHeight}px`; // Set height to the scroll height
        });
    }

    if (!toggler || !slidingPanel || !sidebar) {
        console.error('Sliding panel, toggler button, or sidebar is missing.');
        return;
    }

    // Open/Close panel and toggle button text
    toggler.addEventListener('click', () => {
        const isOpen = slidingPanel.classList.toggle('active'); // Toggle sliding panel visibility
        toggler.classList.toggle('active'); // Toggle button's active state
        toggler.textContent = isOpen ? 'Close' : 'Post'; // Update button text
    });

    // Optional: Close panel and reset button text when form is submitted
    const form = slidingPanel.querySelector('form');
    if (form) {
        form.addEventListener('submit', () => {
            toggler.classList.remove('active');
            slidingPanel.classList.remove('active');
            toggler.textContent = 'Post'; // Reset text to 'Post' after submission
        });
    }

    // Function to update the sliding panel's width and position
    function updateSlidingPanelWidth() {
        if (sidebar) {
            const sidebarWidth = sidebar.offsetWidth;
            const sidebarLeft = sidebar.offsetLeft;

            slidingPanel.style.width = `${sidebarWidth}px`; // Match the width of the sidebar
            slidingPanel.style.left = `${sidebarLeft}px`; // Align to sidebar's position
        }
    }

    // Adjust sliding panel on window resize
    window.addEventListener('resize', updateSlidingPanelWidth);

    // Initialize the sliding panel's width and position
    updateSlidingPanelWidth();
});

----------------------------------------
Filename: translations.js
Content:
// Global grade and workload translations
window.gradeTranslations = {
    "6.0": "A/6.0",
    "5.5": "B/5.5",
    "5.0": "C/5.0",
    "4.5": "D/4.5",
    "4.0": "E/4.0",
    "3.5": "Failed",
  };
  
  window.workloadTranslations = {
    "1": "Walk in the Park",
    "2": "Manageable",
    "3": "Moderate Effort",
    "4": "Challenging",
    "5": "Pain and Suffering",
  };

  // Semester translation function
window.translateSemester = function (semesterNumber) {
    if (typeof semesterNumber !== "number" || semesterNumber < 1) {
      return "Invalid Semester";
    }
  
    const baseYear = 2024; // Starting year for the semester sequence
    const isSpring = semesterNumber % 2 !== 0; // Odd numbers are spring (FS), even are fall (HS)
    const offset = Math.floor((semesterNumber - 1) / 2); // Number of full years offset from baseYear
  
    const year = baseYear + offset;
    const season = isSpring ? "FS" : "HS";
  
    return `${season}${year % 100}`; // Format as FS/HS + last two digits of the year
  };
----------------------------------------
Filename: app.js
Content:
import dotenv from 'dotenv';
dotenv.config();

import {
    supabase,
    addRating,
    fetchRatings,
    fetchProfessors,
    fetchModules,
    fetchDepartments,
    fetchSemesters,
    fetchProfModRelations,
    fetchModProfRelations,
    loginUser,
    registerUser,
    resetPassword,
    updateUserProfile,
    updatePassword,
    updatePreferences,
    fetchRatingHistory,
    deleteUserAccount,
    fetchUserPreferences,
    updateUserPreferences,
    fetchActivityLogs,
    logActivity
} from './db.js';

import express from 'express';
import session from 'express-session';
import bcrypt from 'bcrypt';
import path from 'path'; // Ensure path is imported

import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const app = express();

// Set Pug as the view engine
app.set('view engine', 'pug');
app.set('views', path.join(__dirname, 'views'));

// Middleware to serve static files from 'public' directory
app.use(express.static(path.join(__dirname, 'public'))); // Ensure correct path to public directory
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// Session middleware
app.use(session({
    secret: process.env.SECRET_KEY,
    resave: false,
    saveUninitialized: true,
    cookie: { secure: false }
}));

// Activity logging middleware
app.use(async (req, res, next) => {
    const user = req.session?.user;

    if (user) {
        const activityData = {
            user_id: user.id,
            username: user.username,
            timestamp: new Date().toISOString(),
            http_method: req.method,
            url: req.originalUrl,
            ip_address: req.headers['x-forwarded-for'] || req.socket.remoteAddress,
            user_agent: req.headers['user-agent'],
        };

        try {
            await logActivity(activityData);
            console.log(`[Activity Logged]: ${JSON.stringify(activityData)}`);
        } catch (err) {
            console.error('Failed to log activity:', err);
        }
    } else {
        console.log('No user session; skipping activity logging.');
    }

    next();
});

// route definitions
app.get('/profile', (req, res) => {
    const user = req.session.user;
    if (!user) {
        return res.redirect('/login');
    }
    res.render('general', { user, activeTab: 'general' });
});

app.post('/profile/update', async (req, res) => {
    if (!req.session.user) {
        return res.status(401).send('You must be logged in to update your profile.');
    }

    const { username, email, visibility } = req.body;
    try {
        const userId = req.session.user.id;
        const { error } = await supabase
            .from('users')
            .update({ username, email, visibility })
            .eq('id', userId);

        if (error) throw error;

        // Update the session with new user data
        req.session.user = { ...req.session.user, username, email, visibility };
        res.redirect('/profile');
    } catch (err) {
        console.error('Error updating profile:', err);
        res.status(500).send('Error updating profile');
    }
});

app.get('/profile/password', (req, res) => {
    res.render('password', { activeTab: 'password' });
});

app.post('/profile/password', async (req, res) => {
    const { current_password, new_password } = req.body;
    try {
        await updatePassword(req.session.user.id, current_password, new_password);
        res.redirect('/profile/password');
    } catch (error) {
        console.error('Error updating password:', error);
        res.status(500).send('Error updating password');
    }
});

app.get('/profile/preferences', async (req, res) => {
    const user = req.session.user;
    if (!user) {
        return res.redirect('/login');
    }

    const preferences = await fetchUserPreferences(user.id);
    res.render('preferences', { user, activeTab: 'preferences', preferences });
});

app.post('/profile/preferences', async (req, res) => {
    const user = req.session.user;
    if (!user) {
        return res.redirect('/login');
    }

    const { dark_mode, email_notifications } = req.body;
    const preferences = {
        dark_mode: !!dark_mode,
        email_notifications: !!email_notifications
    };

    await updateUserPreferences(user.id, preferences);
    res.redirect('/profile/preferences');
});

app.get('/profile/privacy', async (req, res) => {
    console.log('Request received for /profile/privacy');
    if (!req.session.user) {
        console.log('No session user found. Redirecting to login.');
        return res.redirect('/login');
    }

    const userId = req.session.user.id;

    try {
        const { data: user, error } = await supabase
            .from('users')
            .select('visibility')
            .eq('id', userId)
            .single();

        if (error) throw error;

        console.log('Fetched user visibility:', user.visibility);
        res.render('privacy', { user: { ...req.session.user, visibility: user.visibility }, activeTab: 'privacy' });
    } catch (err) {
        console.error('Error loading privacy settings:', err);
        res.status(500).send('Error loading privacy settings');
    }
});

app.post('/profile/privacy/update', async (req, res) => {
    if (!req.session.user) {
        return res.status(401).send('You must be logged in to update your profile.');
    }

    const { visibility } = req.body;
    try {
        const userId = req.session.user.id;
        const { error } = await supabase
            .from('users')
            .update({ visibility })
            .eq('id', userId);

        if (error) throw error;

        // Update the session with new user data
        req.session.user = { ...req.session.user, visibility };
        res.redirect('/profile/privacy');
    } catch (err) {
        console.error('Error updating privacy:', err);
        res.status(500).send('Error updating privacy');
    }
});

app.post('/profile/delete', async (req, res) => {
    try {
        await deleteUserAccount(req.session.user.id);
        req.session.destroy();
        res.redirect('/');
    } catch (error) {
        console.error('Error deleting account:', error);
        res.status(500).send('Error deleting account');
    }
});

app.get('/profile/activity', async (req, res) => {
    const user = req.session.user;
    if (!user) {
        return res.redirect('/login');
    }

    const activityLogs = await fetchActivityLogs(user.id);
    res.render('activity', { user, activeTab: 'activity', activityLogs });
});

// Redirect root URL to /home
app.get('/', (req, res) => {
    res.redirect('/home');
});

app.get('/register', (req, res) => {
    res.render('register');
});

app.post('/register', async (req, res) => {
    const { username, email, password } = req.body;
    try {
        await registerUser(username, email, password);
        res.send('User registered successfully');
    } catch (error) {
        console.error('Error registering user:', error);
        res.status(500).send('Error registering user');
    }
});

app.get('/resetpassword', (req, res) => {
    res.render('resetpassword');
});

app.post('/resetpassword', async (req, res) => {
    const { email, username } = req.body;

    try {
        if (!email && !username) {
            return res.status(400).send('Please provide a username or email.');
        }

        // Attempt to reset password based on either username or email
        const identifier = email || username;
        const result = await resetPassword(identifier);

        if (!result) {
            return res.status(404).send('User not found.');
        }

        res.send(`Password reset instructions sent to ${email || username}.`);
    } catch (error) {
        console.error('Error resetting password:', error);
        res.status(500).send('Error resetting password.');
    }
});

app.get('/login', async (req, res) => {
    res.render('login', { user: req.session.user });
});

app.post('/login', async (req, res) => {
    const { username, password } = req.body;
    try {
        const user = await loginUser(username, password);
        req.session.user = user;
        res.redirect('/home');
    } catch (error) {
        console.error('Error logging in user:', error);
        res.status(500).send('Invalid credentials');
    }
});

app.get('/logout', (req, res) => {
    req.session.destroy();
    res.redirect('/home');
});

app.get('/home', async (req, res) => {
    try {
        const { profIdValue, moduleIdValue } = req.query;

        // Fetch initial dropdown options
        const firstDropdown = await fetchProfessors('*');
        const secondDropdown = profIdValue ? await fetchModules('*') : [];

        const originalOptions = {
            firstDropdown,
            secondDropdown,
        };

        // Grade and workload options
        const gradeOptions = {
            3.5: 'Failed / F',
            4.0: 'E',
            4.5: 'D',
            5.0: 'C',
            5.5: 'B',
            6.0: 'A',
        };

        const workloadOptions = {
            1: 'Walk in the Park',
            2: 'Manageable',
            3: 'Moderate Effort',
            4: 'Challenging',
            5: 'Pain and Suffering',
        };

        res.render('home', {
            user: req.session.user,
            selectedProfIdValue: profIdValue || '',
            selectedModuleIdValue: moduleIdValue || '',
            originalOptions,
            gradeOptions,
            workloadOptions,
        });
    } catch (error) {
        console.error('Error rendering home:', error);
        res.status(500).send('Internal Server Error');
    }
});

app.get('/professors', async (req, res) => {
    try {
        const professors = await fetchProfessors('*');
        res.json(professors);
    } catch (err) {
        console.error('Failed to fetch professors:', err);
        res.status(500).send('Failed to load page');
    }
});

app.get('/modules', async (req, res) => {
    try {
        const modules = await fetchModules('*');
        res.json(modules);
    } catch (err) {
        console.error('Failed to fetch modules:', err);
        res.status(500).send('Failed to load page');
    }
});

app.get('/departments', async (req, res) => {
    try {
        const departments = await fetchDepartments();
        res.json(departments);
    } catch (err) {
        console.error('Failed to fetch departments:', err);
        res.status(500).send('Failed to load page');
    }
});

app.get('/relations/professor/:profName', async (req, res) => {
    try {
        const relationsPM = await fetchModProfRelations(req.params.profName);
        res.json(relationsPM);
    } catch (err) {
        console.error('Failed to fetch relations:', err);
        res.status(500).send('Failed to load page');
    }
});

app.get('/relations/module/:moduleName', async (req, res) => {
    try {
        const relationsMP = await fetchProfModRelations(req.params.moduleName);
        res.json(relationsMP);
    } catch (err) {
        console.error('Failed to fetch relations:', err);
        res.status(500).send('Failed to load page');
    }
});

app.get('/chart', async (req, res) => {
    const { category, firstId, secondId } = req.query;
    try {
        const { data: rawData, profIdValue, moduleIdValue } = await fetchRatings(category, firstId, secondId);
        console.log('line 143 app.js: ==========chart===========');
        console.log('line 144 app.js: rawData:', rawData);
        console.log('line 145 app.js: profIdValue:', profIdValue, 'moduleIdValue:', moduleIdValue);
        
        const averages = {};
        const scatterData = [];
        const curveData = [];

        rawData.forEach(rating => {
            scatterData.push({ x: rating.sem_id, y: rating.rating });
            if (!averages[rating.sem_id]) {
                averages[rating.sem_id] = { sum: rating.rating, count: 1 };
            } else {
                averages[rating.sem_id].sum += rating.rating;
                averages[rating.sem_id].count++;
            }
        });

        for (let sem_id in averages) {
            curveData.push({
                x: sem_id,
                y: averages[sem_id].sum / averages[sem_id].count
            });
        }

        const ratingData = { scatter: scatterData, curve: curveData };
        res.json({ ratingData, profIdValue, moduleIdValue });
        console.log('line 168 app.js: ratingData:', ratingData);
        console.log('line 169 app.js: scatterData:', scatterData);
        console.log('line 170 app.js: curveData:', curveData);
    } catch (err) {
        console.error('Failed to fetch ratings:', err);
        res.status(500).send('Failed to load page');
    }
});

app.get('/semester', async (req, res) => {
    try {
        const semesterData = await fetchSemesters();
        console.log('line 181 app.js: semesterData', semesterData);
        res.json(semesterData);
    } catch (error) {
        console.error('Error fetching semesters:', error);
        res.status(500).send('Error fetching semesters');
    }
});

app.post('/submit-rating', async (req, res) => {
    if (!req.session.user) {
        return res.status(401).send('Please login to submit ratings');
    }

    const { comment, rating, prof_id_hidden, sem_id_hidden, module_id_hidden, grade, workload } = req.body;

    try {
        const user_id = req.session.user.id;

        // Save rating along with grade and workload
        await addRating(comment, rating, prof_id_hidden, sem_id_hidden, module_id_hidden, user_id, grade, workload);

        // Redirect back to the home page with the selected dropdowns
        res.redirect(`/home?profIdValue=${prof_id_hidden}&moduleIdValue=${module_id_hidden}`);
    } catch (err) {
        console.error('Error submitting rating:', err);
        res.status(500).send('Error submitting rating');
    }
});

app.get('/comments', async (req, res) => {
    const { prof_id_hidden, module_id_hidden } = req.query;

    if (!prof_id_hidden || !module_id_hidden) {
        return res.status(400).json({ error: 'Missing required parameters.' });
    }

    try {
        const { data, error } = await supabase
            .from('ratings')
            .select('comment, rating, grade, workload, created_at')
            .eq('prof_id', prof_id_hidden)
            .eq('module_id', module_id_hidden);

        if (error) {
            console.error('Error fetching comments:', error);
            return res.status(500).json({ error: 'Failed to fetch comments.' });
        }

        res.json(data);
    } catch (err) {
        console.error('Unexpected error fetching comments:', err);
        res.status(500).json({ error: 'Internal server error.' });
    }
});

app.get('/profile/history', async (req, res) => {
    if (!req.session.user) {
        return res.redirect('/login');
    }

    const userId = req.session.user.id;

    try {
        const { data, error } = await supabase
            .from('ratings')
            .select('rating_id, comment, rating, grade, workload, created_at, prof_id, module_id')
            .eq('user_id', userId);

        if (error) {
            console.error('Error fetching user ratings history:', error);
            return res.status(500).send('Failed to load history.');
        }

        // Serve JSON for AJAX calls
        if (req.headers.accept && req.headers.accept.includes('application/json')) {
            return res.json(data);
        }

        // Render Pug template for regular page load
        res.render('history', { ratings: data, activeTab: 'history' });
    } catch (error) {
        console.error('Unexpected error fetching user ratings history:', error);
        res.status(500).send('Failed to load history.');
    }
});

app.get('/profile/history/:id', async (req, res) => {
    const { id } = req.params;
    const user = req.session.user;
    const userId = req.session.user.id
    console.log('userId:', userId);
    console.log('user:', user);

    if (!user) {
        return res.redirect('/login');
    }

    try {
        const { data: data, error } = await supabase
            .from('ratings')
            .select('*')
            .eq('user_id', userId);

        if (error) {
            throw new Error('Rating not found');
        }

        res.json(data);
    } catch (err) {
        console.error('Error fetching rating data:', err);
        res.status(500).send('Failed to fetch rating data');
    }
});

app.post('/profile/history/edit', async (req, res) => {
    if (!req.session.user) {
        return res.redirect('/login');
    }

    const { rating_id, comment, rating, grade, workload } = req.body;

    try {
        const { error } = await supabase
            .from('ratings')
            .update({ comment, rating, grade, workload })
            .eq('rating_id', rating_id)
            .eq('user_id', req.session.user.id);

        if (error) {
            console.error('Error updating rating:', error);
            return res.status(500).send('Failed to update rating.');
        }

        res.redirect('/profile/history'); // Redirect to the history page
    } catch (error) {
        console.error('Unexpected error updating rating:', error);
        res.status(500).send('Failed to update rating.');
    }
});

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

----------------------------------------
Filename: db.js
Content:
import dotenv from 'dotenv';
dotenv.config();

import bcrypt from 'bcrypt';
import {
    createClient
} from '@supabase/supabase-js';

const supabaseUrl = 'https://jqnesxzpfsfxzqnudtig.supabase.co';
const supabaseKey = process.env.SUPABASE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

async function fetchProfessors(columns = '*') {
    try {
        const { data, error } = await supabase
            .from('professors')
            .select(columns);

        if (error) {
            console.error('Error fetching professors:', error);
            return []; // Return an empty array on error
        }

        if (!data || data.length === 0) {
            console.warn('No professors found.');
            return []; // Return an empty array if no data
        }

        console.log(`line 23 db.js: Fetched ${data.length} professors.`);
        return data;
    } catch (error) {
        console.error('Unexpected error fetching professors:', error);
        return []; // Return an empty array on unexpected error
    }
}

async function fetchModules(columns = '*') {
    try {
        const { data, error } = await supabase
            .from('modules')
            .select(columns);

        if (error) {
            console.error('Error fetching modules:', error);
            return []; // Return an empty array on error
        }

        if (!data || data.length === 0) {
            console.warn('No modules found.');
            return []; // Return an empty array if no data
        }

        console.log(`line 41 db.js: Fetched ${data.length} modules.`);
        return data;
    } catch (error) {
        console.error('Unexpected error fetching modules:', error);
        return []; // Return an empty array on unexpected error
    }
}

async function fetchDepartments() {
    try {
        const { data, error } = await supabase
            .from('departments')
            .select('*');

        if (error) {
            console.error('Error fetching departments:', error);
            return [];
        }
        console.log('line 59 db.js: Fetched departments:', data[0], '...');
        return data;
    } catch (error) {
        console.error('Unexpected error fetching departments:', error);
        return [];
    }
}

async function fetchSemesters() {
    try {
        const { data, error } = await supabase
        .from('semester')
        .select('*');

        if (error) {
            console.error('Error fetching semesters:', error);
            return [];
        }
        console.log('line 77 db.js: Fetched semesters:', data[0], '...');
        return data;
    } catch (error) {
        console.error('Unexpected error fetching semesters:', error);
        return [];
    }
}

async function fetchProfModRelations(profName) {
    try {
        const { data: professorData, error: professorError } = await supabase
            .from('professors')
            .select('prof_id')
            .eq('name', profName);

        if (professorError) {
            console.error('Error fetching professor data:', professorError);
            return [];
        }

        const professorIds = professorData.map(professor => professor.prof_id);

        const { data: relationsData, error: relationsError } = await supabase
            .from('professors_modules')
            .select('module_id')
            .in('prof_id', professorIds);

        if (relationsError) {
            console.error('Error fetching relations data:', relationsError);
            return [];
        }

        const moduleIds = relationsData.map(relation => relation.module_id);

        const { data: modulesData, error: modulesError } = await supabase
            .from('modules')
            .select('name, module_id')
            .in('module_id', moduleIds);

        if (modulesError) {
            console.error('Error fetching module data:', modulesError);
            return [];
        }

        return modulesData;
    } catch (error) {
        console.error('Unexpected error fetching relations:', error);
        return [];
    }
}

async function fetchModProfRelations(moduleName) {
    try {
        const { data: moduleData, error: moduleError } = await supabase
            .from('modules')
            .select('module_id')
            .eq('name', moduleName);

        if (moduleError) {
            console.error('Error fetching module data:', moduleError);
            return [];
        }

        const moduleIds = moduleData.map(module => module.module_id);

        const { data: relationsData, error: relationsError } = await supabase
            .from('professors_modules')
            .select('prof_id')
            .in('module_id', moduleIds);

        if (relationsError) {
            console.error('Error fetching relations data:', relationsError);
            return [];
        }

        const professorIds = relationsData.map(relation => relation.prof_id);

        const { data: professorsData, error: professorsError } = await supabase
            .from('professors')
            .select('name, prof_id')
            .in('prof_id', professorIds);

        if (professorsError) {
            console.error('Error fetching professor data:', professorsError);
            return [];
        }

        return professorsData;
    } catch (error) {
        console.error('Unexpected error fetching relations:', error);
        return [];
    }
}

async function fetchRatings(category, firstId, secondId) {

    console.log('line 173 db.js: 1. category passed:', category, 'profId passed:', firstId, 'moduleId passed:', secondId);
    
    let profId, moduleId;
    if (category === 'professor') {
        profId = firstId;
        moduleId = secondId;
    } else {
        profId = secondId;
        moduleId = firstId;
    }

    console.log('line 184 db.js: 2. category passed:', category, 'profId passed:', profId, 'moduleId passed:', moduleId);

    // Fetch the actual IDs from the professors and modules tables
    let profIdValue, moduleIdValue;
    
    if (profId) {
        const profData = await fetchProfessors();
        const prof = profData.find(p => p.name === profId);
        profIdValue = prof ? prof.prof_id : null;
    }

    if (moduleId) {
        const modData = await fetchModules();
        const module = modData.find(m => m.name === moduleId);
        moduleIdValue = module ? module.module_id : null;
    }

    if (!profIdValue || !moduleIdValue) {
        console.error('Invalid professor or module name provided');
        return [];
    }

    console.log('line 206 db.js: 3. Using profIdValue:', profIdValue, 'and moduleIdValue:', moduleIdValue);
    try {
        const { data, error } = await supabase
            .from('ratings')
            .select('*')
            .eq('prof_id', profIdValue)
            .eq('module_id', moduleIdValue);

        if (error) {
            console.error('Error fetching ratings:', error);
            return [];
        }
        console.log('line 218 db.js: Fetched ratings:', data[0], '...');
        return { data, profIdValue, moduleIdValue };  // Return as an object
    } catch (error) {
        console.error('Unexpected error fetching ratings:', error);
        return [];
    }
}

async function addRating(comment, rating, prof_id, sem_id, module_id, user_id, grade = null, workload = null) {
    try {
        const { data, error } = await supabase.from('ratings').insert([{
            comment,
            rating,
            prof_id,
            sem_id,
            module_id,
            user_id,
            grade,
            workload,
        }]);

        if (error) {
            console.error('Error inserting rating:', error);
            throw error;
        }

        console.log('Rating successfully added:', data);
        return data;
    } catch (error) {
        console.error('Unexpected error adding rating:', error);
        throw error;
    }
}

async function loginUser(username, password) {
    const { data: user, error } = await supabase.from('users').select('*').eq('username', username).single();
    if (error || !user) {
      throw new Error('Invalid credentials');
    }
    const match = await bcrypt.compare(password, user.password_hash);
    if (!match) {
      throw new Error('Invalid credentials');
    }
    return user;
}

async function registerUser(username, email, password) {
    const passwordHash = await bcrypt.hash(password, 10);
    const { data, error } = await supabase.from('users').insert([{ username, email, password, password_hash: passwordHash }]);
    if (error) {
        console.error('Error registering user:', error);
        throw error;
    }
    return data;
}

async function resetPassword(identifier) {
    try {
        const { data: user, error } = await supabase
            .from('users')
            .select('id, email')
            .or(`username.eq.${identifier},email.eq.${identifier}`)
            .single();

        if (error || !user) {
            console.error('User not found for reset:', error);
            return null;
        }

        const tempPassword = Math.random().toString(36).substring(2, 8); // e.g., "temp123"
        const hashedPassword = await bcrypt.hash(tempPassword, 10);

        const { error: updateError } = await supabase
            .from('users')
            .update({ password_hash: hashedPassword })
            .eq('id', user.id);

        if (updateError) {
            console.error('Error updating password:', updateError);
            return null;
        }

        await sendPasswordResetEmail(user.email, tempPassword);

        console.log(`Temporary password sent to ${user.email}`);
        return { email: user.email, tempPassword };
    } catch (error) {
        console.error('Error during password reset logic:', error);
        throw error;
    }
}

async function sendPasswordResetEmail(email, resetLink) {
    // Replace this with actual email service logic
    console.log(`Sending password reset email to ${email} with link: ${resetLink}`);
}

async function updateUserProfile(userId, username, email, visibility) {
    const { error } = await supabase
        .from('users')
        .update({ username, email, visibility })
        .eq('id', userId);
    if (error) throw error;
}

async function updatePassword(userId, currentPassword, newPassword) {
    const { data: user, error } = await supabase
        .from('users')
        .select('password_hash')
        .eq('id', userId)
        .single();

    if (error || !user) throw new Error('User not found');
    const match = await bcrypt.compare(currentPassword, user.password_hash);
    if (!match) throw new Error('Invalid current password');

    const hashedPassword = await bcrypt.hash(newPassword, 10);
    const { error: updateError } = await supabase
        .from('users')
        .update({ password_hash: hashedPassword })
        .eq('id', userId);

    if (updateError) throw updateError;
}

async function updatePreferences(userId, preferences) {
    const { error } = await supabase
        .from('users')
        .update({ preferences })
        .eq('id', userId);
    if (error) throw error;
}

async function fetchRatingHistory(userId) {
    try {
        const { data, error } = await supabase
            .from('ratings')
            .select('id, comment, rating, prof_id, sem_id, module_id, created_at')
            .eq('user_id', userId);

        if (error) {
            console.error('Error fetching rating history:', error);
            throw error;
        }

        return data;
    } catch (error) {
        console.error('Unexpected error fetching rating history:', error);
        throw error;
    }
}

async function deleteUserAccount(userId) {
    const { error } = await supabase
        .from('users')
        .delete()
        .eq('id', userId);
    if (error) throw error;
}

async function fetchUserPreferences(userId) {
    try {
        const { data, error } = await supabase
            .from('users')
            .select('preferences')
            .eq('id', userId)
            .single();

        if (error) {
            console.error('Error fetching user preferences:', error);
            throw error;
        }
        return data.preferences || {};
    } catch (error) {
        console.error('Unexpected error fetching user preferences:', error);
        return {};
    }
}

async function updateUserPreferences(userId, preferences) {
    try {
        const { error } = await supabase
            .from('users')
            .update({ preferences })
            .eq('id', userId);

        if (error) {
            console.error('Error updating user preferences:', error);
            throw error;
        }
    } catch (error) {
        console.error('Unexpected error updating user preferences:', error);
    }
}

async function fetchActivityLogs(userId) {
    try {
        const { data, error } = await supabase
            .from('activity_logs')
            .select('*')
            .eq('user_id', userId)
            .eq('visibility');

        if (error) {
            console.error('Error fetching privacy:', error);
            return [];
        }
        return data;
    } catch (error) {
        console.error('Unexpected error fetching privacy:', error);
        return [];
    }
}

export async function logActivity(activityData) {
    const { user_id, action } = activityData;

    try {
        const { data, error } = await supabase
            .from('activity')
            .insert([
                {
                    user_id,
                    action, // Simplify to include only the relevant columns
                    created_at: new Date().toISOString() // Optional: Supabase can auto-generate this
                }
            ]);

        if (error) {
            console.error('Error logging activity to database:', error);
            throw error;
        }

        return data;
    } catch (err) {
        console.error('Unexpected error during activity logging:', err);
        throw err;
    }
}

async function fetchPrivacy(userId) {
    try {
        const { data, error } = await supabase
            .from('users')
            .select('*')
            .eq('user_id', userId)
            .order('timestamp', { ascending: false });

        if (error) {
            console.error('Error fetching activity logs:', error);
            return [];
        }
        return data;
    } catch (error) {
        console.error('Unexpected error fetching activity logs:', error);
        return [];
    }
}

export {
    supabase,
    addRating,
    fetchRatings,
    fetchProfessors,
    fetchModules,
    fetchDepartments,
    fetchSemesters,
    fetchProfModRelations,
    fetchModProfRelations,
    loginUser,
    registerUser,
    resetPassword,
    updateUserProfile,
    updatePassword,
    updatePreferences,
    fetchRatingHistory,
    deleteUserAccount,
    fetchUserPreferences,
    updateUserPreferences,
    fetchActivityLogs,
    fetchPrivacy
};

----------------------------------------
Filename: hashPasswords.js
Content:
import dotenv from 'dotenv';
dotenv.config();

import { createClient } from '@supabase/supabase-js';
import bcrypt from 'bcrypt';

const supabaseUrl = 'https://jqnesxzpfsfxzqnudtig.supabase.co';
const supabaseKey = process.env.SUPABASE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

async function hashPasswords() {
  try {
    const { data: users, error } = await supabase.from('users').select('*');
    if (error) {
      console.error('Error fetching users:', error);
      return;
    }

    console.log('Fetched users:', users);

    for (const user of users) {
      // Check if the password_hash is empty or already hashed
      if (!user.password_hash || !user.password_hash.startsWith('$2b$')) {
        const passwordToHash = user.password || user.password_hash;
        const hashedPassword = await bcrypt.hash(passwordToHash, 10);
        
        const { error: updateError } = await supabase
          .from('users')
          .update({ password_hash: hashedPassword })
          .eq('id', user.id);
          
        if (updateError) {
          console.error(`Error updating user ${user.id}:`, updateError);
        } else {
          console.log(`User ${user.id} password updated.`);
        }
      } else {
        console.log(`User ${user.id} password is already hashed.`);
      }
    }
  } catch (error) {
    console.error('Unexpected error:', error);
  }
}

hashPasswords();

----------------------------------------
